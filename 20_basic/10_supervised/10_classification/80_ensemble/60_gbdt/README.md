# GBDT

## 简介

GBDT 的核心就在于：**每一棵树学的是之前所有树结论和的残差**，这个残差就是一个加预测值后能得真实值的累加量。比如A的真实年龄是18岁，但第一棵树的预测年龄是12岁，差了6岁，即残差为6岁。那么在第二棵树里我们把A的年龄设为6岁去学习，如果第二棵树真的能把A分到6岁的叶子节点，那累加两棵树的结论就是A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在1岁的残差，第三棵树里A的年龄就变成1岁，继续学习。

在 GBDT 的迭代中，假设我们前一轮迭代得到的强学习器是 $𝑓_{𝑡−1}(𝑥)$、 损失函数是 $L(y,f_{t-1}(x))$，本轮迭代的目标是找到一个 CART 回归树模型的弱学习器 $h_t(x)$，让本轮的损失函数 $L(y,f_{t}(x))=L(y,f_{t-1}(x)+h_t(x))$ 最小。也就是本轮迭代找到决策树，要让样本的损失尽量变得更小。

GBDT 的思想可以用一个通俗的例子解释，假如有个人30岁，我们首先用20岁去拟合，发现损失有10岁，这时我们用 6 岁去拟合剩下的损失，发现差距还有 4 岁，第三轮我们用 3 岁拟合剩下的差距，差距就只有 1 岁了。如果我们的迭代轮数还没有完，可以继续迭代下面，每一轮迭代，拟合的岁数误差都会减小。

### 残差

假设现在有样本集 $(x_1, y_1), (x_2,y_2),...(x_n, y_n)$，用模型 $F(x)$ 去拟合该数据集，使得这批样本的平方损失函数（即 $\frac{1}{2}\sum_0^n(y_i-F(x_i)^2)$ ）最小。但发现虽然模型的拟合效果很好，但仍然有一些差距，比如预测值 $F(x_1)=0.8$ 而真实值 $y_1=0.9$，$F(x_2)=1.4$ 而真实值 $y_2=1.3$ 等。**在不允许更改原来模型的参数的情况下，那如何进一步来提高模型的拟合能力？**既然不能更改原来模型的参数，那么意味着必须在原来模型的基础之上做改善，最直观的做法就是建立一个新的模型 $f(x)$ 来拟合 $F(x)$ 未完全拟合真实样本的残差，即 $y-F(x)$。所以对于新的数据集来说，拟合的样本集就变成了：$(x_1,y1-F(x_1)), (x_2, y_2-F(x_2)),...(x_n,y_n-F(x_n))$。

$y_i-F(x_i)$ 被称为残差，这一部分也就是原先的模型 $F(x_i)$ 未能完全拟合的部分，所以交给新的模型来完成。gbdt（Gradient Boosting Decision Tree）中的 gradient 被称为梯度，也就是一阶导。对比原先模型中的损失函数-平方损失函数 $\frac{1}{2}\sum_0^n(y_i-F(x_i)^2)$ ，它的一阶导其实就是残差的形式。

## 原理

GBDT 是通过加法模型（即基函数的线性组合），以及不断减小训练过程产生的残差来达到将数据分类或者回归的算法。GBDT 通过多轮迭代，每轮迭代产生一个弱分类器，每个分类器在上一轮分类器的**残差**基础上进行训练。对弱分类器的要求一般是足够简单，并且是低方差和高偏差的。因为训练的过程是通过降低偏差来不断提高最终分类器的精度。弱分类器一般会选择 决策树的 Cart 树。由于上述高偏差和简单的要求，每个分类回归树的深度不会很深，最终的总分类器是将每轮训练得到的弱分类器加权求和得到的。

模型最终描述为：$F_m(x)=\sum_{m=1}^MT(x;\theta_m)$，模型一共训练 M 轮，每轮产生一个弱分类器 $T(x;\theta_m)$。

<img src="figures/666027-20171030203845058-619624621.png" alt="img" style="zoom:70%;" />

$F_{m−1}(x)$ 为当前的模型，gbdt 通过经验风险极小化来确定下一个弱分类器的参数。具体到损失函数本身 L 的选择，有平方损失函数，0-1损失函数，对数损失函数等等。如果选择平方损失函数，那么这个差值其实就是平常所说的残差。



TODO

https://www.cnblogs.com/pinard/p/6140514.html

我们介绍了 GBDT 的基本思路，但是没有解决损失函数拟合方法的问题。针对这个问题，大牛 Freidman 提出了用损失函数的负梯度来拟合本轮损失的近似值，进而拟合一个 CART 回归树。第 t 轮的第i个样本的损失函数的负梯度表示为

*𝑟**𝑡**𝑖*=−[∂*𝐿*(*𝑦**𝑖*,*𝑓*(*𝑥**𝑖*)))∂*𝑓*(*𝑥**𝑖*)]*𝑓*(*𝑥*)=*𝑓**𝑡*−1(*𝑥*)



　　　　利用(*𝑥**𝑖*,*𝑟**𝑡**𝑖*)(*𝑖*=1,2,..*𝑚*)

,我们可以拟合一颗CART回归树，得到了第t颗回归树，其对应的叶节点区域*𝑅**𝑡**𝑗*,*𝑗*=1,2,...,*𝐽*

。其中J为叶子节点的个数。

　　　　针对每一个叶子节点里的样本，我们求出使损失函数最小，也就是拟合叶子节点最好的的输出值*𝑐**𝑡**𝑗*

如下：

*𝑐**𝑡**𝑗*=*𝑎**𝑟**𝑔**𝑚**𝑖**𝑛*⏟*𝑐*∑*𝑥**𝑖*∈*𝑅**𝑡**𝑗**𝐿*(*𝑦**𝑖*,*𝑓**𝑡*−1(*𝑥**𝑖*)+*𝑐*)



　　　　这样我们就得到了本轮的决策树拟合函数如下：

*ℎ**𝑡*(*𝑥*)=∑*𝑗*=1*𝐽**𝑐**𝑡**𝑗**𝐼*(*𝑥*∈*𝑅**𝑡**𝑗*)





　　　　从而本轮最终得到的强学习器的表达式如下：

*𝑓**𝑡*(*𝑥*)=*𝑓**𝑡*−1(*𝑥*)+∑*𝑗*=1*𝐽**𝑐**𝑡**𝑗**𝐼*(*𝑥*∈*𝑅**𝑡**𝑗*)





　　　　通过损失函数的负梯度来拟合，我们找到了一种通用的拟合损失误差的办法，这样无轮是分类问题还是回归问题，我们通过其损失函数的负梯度的拟合，就可以用GBDT来解决我们的分类回归问题。区别仅仅在于损失函数不同导致的负梯度不同而已。

#  3. GBDT回归算法

　　　　好了，有了上面的思路，下面我们总结下GBDT的回归算法。为什么没有加上分类算法一起？那是因为分类算法的输出是不连续的类别值，需要一些处理才能使用负梯度，我们在下一节讲。

　　　　输入是训练集样本*𝑇*={(*𝑥*,*𝑦*1),(*𝑥*2,*𝑦*2),...(*𝑥**𝑚*,*𝑦**𝑚*)}

， 最大迭代次数T, 损失函数L。

　　　　输出是强学习器f(x)

　　　　1) 初始化弱学习器

*𝑓*0(*𝑥*)=*𝑎**𝑟**𝑔**𝑚**𝑖**𝑛*⏟*𝑐*∑*𝑖*=1*𝑚**𝐿*(*𝑦**𝑖*,*𝑐*)





　　　　2) 对迭代轮数t=1,2,...T有：

　　　　　　a)对样本i=1,2，...m，计算负梯度

*𝑟**𝑡**𝑖*=−[∂*𝐿*(*𝑦**𝑖*,*𝑓*(*𝑥**𝑖*)))∂*𝑓*(*𝑥**𝑖*)]*𝑓*(*𝑥*)=*𝑓**𝑡*−1(*𝑥*)





　　　　　　b)利用(*𝑥**𝑖*,*𝑟**𝑡**𝑖*)(*𝑖*=1,2,..*𝑚*)

, 拟合一颗CART回归树,得到第t颗回归树，其对应的叶子节点区域为*𝑅**𝑡**𝑗*,*𝑗*=1,2,...,*𝐽*

。其中J为回归树t的叶子节点的个数。

　　　　　　c) 对叶子区域j =1,2,..J,计算最佳拟合值

*𝑐**𝑡**𝑗*=*𝑎**𝑟**𝑔**𝑚**𝑖**𝑛*⏟*𝑐*∑*𝑥**𝑖*∈*𝑅**𝑡**𝑗**𝐿*(*𝑦**𝑖*,*𝑓**𝑡*−1(*𝑥**𝑖*)+*𝑐*)





　　　　　　d) 更新强学习器

*𝑓**𝑡*(*𝑥*)=*𝑓**𝑡*−1(*𝑥*)+∑*𝑗*=1*𝐽**𝑐**𝑡**𝑗**𝐼*(*𝑥*∈*𝑅**𝑡**𝑗*)





　　　　3) 得到强学习器f(x)的表达式

*𝑓*(*𝑥*)=*𝑓**𝑇*(*𝑥*)=*𝑓*0(*𝑥*)+∑*𝑡*=1*𝑇*∑*𝑗*=1*𝐽**𝑐**𝑡**𝑗**𝐼*(*𝑥*∈*𝑅**𝑡**𝑗*)





# 4. GBDT分类算法

　　　　这里我们再看看GBDT分类算法，GBDT的分类算法从思想上和GBDT的回归算法没有区别，但是由于样本输出不是连续的值，而是离散的类别，导致我们无法直接从输出类别去拟合类别输出的误差。

　　　　为了解决这个问题，主要有两个方法，一个是用指数损失函数，此时GBDT退化为Adaboost算法。另一种方法是用类似于逻辑回归的对数似然损失函数的方法。也就是说，我们用的是类别的预测概率值和真实概率值的差来拟合损失。本文仅讨论用对数似然损失函数的GBDT分类。而对于对数似然损失函数，我们又有二元分类和多元分类的区别。

## 4.1 二元GBDT分类算法

　　　　对于二元GBDT，如果用类似于逻辑回归的对数似然损失函数，则损失函数为：

*𝐿*(*𝑦*,*𝑓*(*𝑥*))=*𝑙**𝑜**𝑔*(1+*𝑒**𝑥**𝑝*(−*𝑦**𝑓*(*𝑥*)))





　　　　其中*𝑦*∈{−1,+1}

。则此时的负梯度误差为

*𝑟**𝑡**𝑖*=−[∂*𝐿*(*𝑦*,*𝑓*(*𝑥**𝑖*)))∂*𝑓*(*𝑥**𝑖*)]*𝑓*(*𝑥*)=*𝑓**𝑡*−1(*𝑥*)=*𝑦**𝑖*/(1+*𝑒**𝑥**𝑝*(*𝑦**𝑖**𝑓*(*𝑥**𝑖*)))



　　　　对于生成的决策树，我们各个叶子节点的最佳负梯度拟合值为

*𝑐**𝑡**𝑗*=*𝑎**𝑟**𝑔**𝑚**𝑖**𝑛*⏟*𝑐*∑*𝑥**𝑖*∈*𝑅**𝑡**𝑗**𝑙**𝑜**𝑔*(1+*𝑒**𝑥**𝑝*(−*𝑦**𝑖*(*𝑓**𝑡*−1(*𝑥**𝑖*)+*𝑐*)))





　　　　由于上式比较难优化，我们一般使用近似值代替

*𝑐**𝑡**𝑗*=∑*𝑥**𝑖*∈*𝑅**𝑡**𝑗**𝑟**𝑡**𝑖*/∑*𝑥**𝑖*∈*𝑅**𝑡**𝑗*|*𝑟**𝑡**𝑖*|(1−|*𝑟**𝑡**𝑖*|)





　　　　除了负梯度计算和叶子节点的最佳负梯度拟合的线性搜索，二元GBDT分类和GBDT回归算法过程相同。

## 4.2 多元GBDT分类算法

　　　　多元GBDT要比二元GBDT复杂一些，对应的是多元逻辑回归和二元逻辑回归的复杂度差别。假设类别数为K，则此时我们的对数似然损失函数为：

*𝐿*(*𝑦*,*𝑓*(*𝑥*))=−∑*𝑘*=1*𝐾**𝑦**𝑘**𝑙**𝑜**𝑔**𝑝**𝑘*(*𝑥*)





　　　　其中如果样本输出类别为k，则*𝑦**𝑘*=1

。第k类的概率*𝑝**𝑘*(*𝑥*)的表达式为：

*𝑝**𝑘*(*𝑥*)=*𝑒**𝑥**𝑝*(*𝑓**𝑘*(*𝑥*))/∑*𝑙*=1*𝐾**𝑒**𝑥**𝑝*(*𝑓**𝑙*(*𝑥*))



　　　　集合上两式，我们可以计算出第*𝑡*

轮的第*𝑖*个样本对应类别*𝑙*的负梯度误差为

*𝑟**𝑡**𝑖**𝑙*=−[∂*𝐿*(*𝑦**𝑖*,*𝑓*(*𝑥**𝑖*)))∂*𝑓*(*𝑥**𝑖*)]*𝑓**𝑘*(*𝑥*)=*𝑓**𝑙*,*𝑡*−1(*𝑥*)=*𝑦**𝑖**𝑙*−*𝑝**𝑙*,*𝑡*−1(*𝑥**𝑖*)



　　　　观察上式可以看出，其实这里的误差就是样本*𝑖*

对应类别*𝑙*的真实概率和*𝑡*−1

轮预测概率的差值。

　　　　对于生成的决策树，我们各个叶子节点的最佳负梯度拟合值为

*𝑐**𝑡**𝑗**𝑙*=*𝑎**𝑟**𝑔**𝑚**𝑖**𝑛*⏟*𝑐**𝑗**𝑙*∑*𝑖*=0*𝑚*∑*𝑘*=1*𝐾**𝐿*(*𝑦**𝑘*,*𝑓**𝑡*−1,*𝑙*(*𝑥*)+∑*𝑗*=0*𝐽**𝑐**𝑗**𝑙**𝐼*(*𝑥**𝑖*∈*𝑅**𝑡**𝑗**𝑙*))





　　　　由于上式比较难优化，我们一般使用近似值代替

*𝑐**𝑡**𝑗**𝑙*=*𝐾*−1*𝐾*∑*𝑥**𝑖*∈*𝑅**𝑡**𝑗**𝑙**𝑟**𝑡**𝑖**𝑙*∑*𝑥**𝑖*∈*𝑅**𝑡**𝑖**𝑙*|*𝑟**𝑡**𝑖**𝑙*|(1−|*𝑟**𝑡**𝑖**𝑙*|)





　　　　除了负梯度计算和叶子节点的最佳负梯度拟合的线性搜索，多元GBDT分类和二元GBDT分类以及GBDT回归算法过程相同。

# 5. GBDT常用损失函数

　　　　这里我们再对常用的GBDT损失函数做一个总结。

　　　　对于分类算法，其损失函数一般有对数损失函数和指数损失函数两种:

　　　　a) 如果是指数损失函数，则损失函数表达式为

*𝐿*(*𝑦*,*𝑓*(*𝑥*))=*𝑒**𝑥**𝑝*(−*𝑦**𝑓*(*𝑥*))





　　　　其负梯度计算和叶子节点的最佳负梯度拟合参见Adaboost原理篇。

　　　　b) 如果是对数损失函数，分为二元分类和多元分类两种，参见4.1节和4.2节。

　　　　

　　　　对于回归算法，常用损失函数有如下4种:

　　　　a)均方差，这个是最常见的回归损失函数了

*𝐿*(*𝑦*,*𝑓*(*𝑥*))=(*𝑦*−*𝑓*(*𝑥*))2





　　　　b)绝对损失，这个损失函数也很常见

*𝐿*(*𝑦*,*𝑓*(*𝑥*))=|*𝑦*−*𝑓*(*𝑥*)|





　　　　　　对应负梯度误差为：

*𝑠**𝑖**𝑔**𝑛*(*𝑦**𝑖*−*𝑓*(*𝑥**𝑖*))





　　　　c)Huber损失，它是均方差和绝对损失的折衷产物，对于远离中心的异常点，采用绝对损失，而中心附近的点采用均方差。这个界限一般用分位数点度量。损失函数如下：



*𝐿*(*𝑦*,*𝑓*(*𝑥*))={12(*𝑦*−*𝑓*(*𝑥*))2*𝛿*(|*𝑦*−*𝑓*(*𝑥*)|−*𝛿*2)|*𝑦*−*𝑓*(*𝑥*)|≤*𝛿*|*𝑦*−*𝑓*(*𝑥*)|>*𝛿*





　　　　对应的负梯度误差为：



*𝑟*(*𝑦**𝑖*,*𝑓*(*𝑥**𝑖*))={*𝑦**𝑖*−*𝑓*(*𝑥**𝑖*)*𝛿**𝑠**𝑖**𝑔**𝑛*(*𝑦**𝑖*−*𝑓*(*𝑥**𝑖*))|*𝑦**𝑖*−*𝑓*(*𝑥**𝑖*)|≤*𝛿*|*𝑦**𝑖*−*𝑓*(*𝑥**𝑖*)|>*𝛿*





　　　　d) 分位数损失。它对应的是分位数回归的损失函数，表达式为

*𝐿*(*𝑦*,*𝑓*(*𝑥*))=∑*𝑦*≥*𝑓*(*𝑥*)*𝜃*|*𝑦*−*𝑓*(*𝑥*)|+∑*𝑦*<*𝑓*(*𝑥*)(1−*𝜃*)|*𝑦*−*𝑓*(*𝑥*)|





　　　　　　其中*𝜃*

为分位数，需要我们在回归前指定。对应的负梯度误差为：



*𝑟*(*𝑦**𝑖*,*𝑓*(*𝑥**𝑖*))={*𝜃**𝜃*−1*𝑦**𝑖*≥*𝑓*(*𝑥**𝑖*)*𝑦**𝑖*<*𝑓*(*𝑥**𝑖*)





　　　　对于Huber损失和分位数损失，主要用于健壮回归，也就是减少异常点对损失函数的影响。

# 6. GBDT的正则化

　　　　和Adaboost一样，我们也需要对GBDT进行正则化，防止过拟合。GBDT的正则化主要有三种方式。

　　　　第一种是和Adaboost类似的正则化项，即步长(learning rate)。定义为*𝜈*

,对于前面的弱学习器的迭代

*𝑓**𝑘*(*𝑥*)=*𝑓**𝑘*−1(*𝑥*)+*ℎ**𝑘*(*𝑥*)



　　　　如果我们加上了正则化项，则有

*𝑓**𝑘*(*𝑥*)=*𝑓**𝑘*−1(*𝑥*)+*𝜈**ℎ**𝑘*(*𝑥*)





　　　　*𝜈*

的取值范围为0<*𝜈*≤1。对于同样的训练集学习效果，较小的*𝜈*

意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。

 

　　　　第二种正则化的方式是通过子采样比例（subsample）。取值为(0,1]。注意这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。推荐在[0.5, 0.8]之间。

　　　　使用了子采样的GBDT有时也称作随机梯度提升树(Stochastic Gradient Boosting Tree,  SGBT)。由于使用了子采样，程序可以通过采样分发到不同的任务去做boosting的迭代过程，最后形成新树，从而减少弱学习器难以并行学习的弱点。

 

　　　　第三种是对于弱学习器即CART回归树进行正则化剪枝。在决策树原理篇里我们已经讲过，这里就不重复了。

# 7. GBDT小结　

　　　　GBDT终于讲完了，GDBT本身并不复杂，不过要吃透的话需要对集成学习的原理，决策树原理和各种损失函树有一定的了解。由于GBDT的卓越性能，只要是研究机器学习都应该掌握这个算法，包括背后的原理和应用调参方法。目前GBDT的算法比较好的库是xgboost。当然scikit-learn也可以。

　　　　最后总结下GBDT的优缺点。

　　　　GBDT主要的优点有：

　　　　1) 可以灵活处理各种类型的数据，包括连续值和离散值。

　　　　2) 在相对少的调参时间情况下，预测的准确率也可以比较高。这个是相对SVM来说的。

　　　　3）使用一些健壮的损失函数，对异常值的鲁棒性非常强。比如 Huber损失函数和Quantile损失函数。

　　　　GBDT的主要缺点有：

　　　　1)由于弱学习器之间存在依赖关系，难以并行训练数据。不过可以通过自采样的SGBT来达到部分并行。

